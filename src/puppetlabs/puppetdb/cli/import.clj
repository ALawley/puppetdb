(ns puppetlabs.puppetdb.cli.import
  "Import utility

   This is a command-line tool for importing data into PuppetDB. It expects
   as input a tarball generated by the PuppetDB `export` command-line tool."
  (:import  [puppetlabs.puppetdb.archive TarGzReader]
            [org.apache.commons.compress.archivers.tar TarArchiveEntry])
  (:require [me.raynes.fs :as fs]
            [puppetlabs.puppetdb.client :as client]
            [puppetlabs.puppetdb.archive :as archive]
            [puppetlabs.puppetdb.cheshire :as json]
            [clojure.java.io :as io]
            [slingshot.slingshot :refer [try+]]
            [puppetlabs.puppetdb.schema :refer [defn-validated]]
            [puppetlabs.puppetdb.utils :as utils
             :refer [base-url-schema export-root-dir]]
            [puppetlabs.kitchensink.core :as kitchensink]
            [puppetlabs.puppetdb.cli.export :refer [export-metadata-file-name]]
            [schema.core :as s]
            [slingshot.slingshot :refer [try+ throw+]]))

(def cli-description "Import PuppetDB catalog data from a backup file")

(def metadata-path
  (.getPath (io/file export-root-dir export-metadata-file-name)))

(defn parse-metadata
  "Parses the export metadata file to determine, e.g., what versions of the
  commands should be used during import."
  [tarball]
  {:post [(map? %)
          (:command_versions %)]}
  (with-open [tar-reader (archive/tarball-reader tarball)]
    (when-not (archive/find-entry tar-reader metadata-path)
      (throw (IllegalStateException.
              (format "Unable to find export metadata file '%s' in archive '%s'"
                      metadata-path
                      tarball))))
    (-> tar-reader
        archive/read-entry-content
        (json/parse-string true))))

(defn file-pattern
  [entity]
  (re-pattern (str "^" (.getPath (io/file export-root-dir entity ".*\\.json")) "$")))

(defn-validated process-tar-entry
  "Determine the type of an entry from the exported archive, and process it
  accordingly."
  [^TarGzReader tar-reader :- TarGzReader
   ^TarArchiveEntry tar-entry :- TarArchiveEntry
   dest :- base-url-schema
   command-versions :- {s/Any s/Any}]
  (let [path (.getName tar-entry)]
    (condp re-find path
      (file-pattern "catalogs")
      (do (println (format "Importing catalog from archive entry '%s'" path))
          ;; NOTE: these submissions are async and we have no guarantee that they
          ;;   will succeed. We might want to add something at the end of the import
          ;;   that polls puppetdb until the command queue is empty, then does a
          ;;   query to the /nodes endpoint and shows the set difference between
          ;;   the list of nodes that we submitted and the output of that query
          (client/submit-catalog dest
                                 (:replace_catalog command-versions)
                                 (archive/read-entry-content tar-reader)))
      (file-pattern "reports")
      (do (println (format "Importing report from archive entry '%s'" path))
          (client/submit-report dest
                                (:store_report command-versions)
                                (archive/read-entry-content tar-reader)))
      (file-pattern "facts")
      (do (println (format "Importing facts from archive entry '%s'" path))
          (client/submit-facts dest
                               (:replace_facts command-versions)
                               (archive/read-entry-content tar-reader)))
      nil)))

(defn- validate-cli!
  [args]
  (let [specs [["-i" "--infile INFILE" "Path to backup file (required)"]
               ["-H" "--host HOST" "Hostname of PuppetDB server"
                :default "127.0.0.1"]
               ["-p" "--port PORT" "Port to connect to PuppetDB server (HTTP protocol only)"
                :default 8080
                :parse-fn #(Integer/parseInt %)]]
        required [:infile]
        validate-file-exists! (fn [{:keys [infile] :as options}]
                             (when-not (fs/exists? infile)
                               (throw+ {:type ::cli-help
                                        :message (format "Import from %s failed. File not found." infile)}))
                             options)
        construct-base-url (fn [{:keys [host port] :as options}]
                             (-> options
                                 (assoc :base-url (utils/pdb-cmd-base-url host port :v1))
                                 (dissoc :host :port)))]
    (utils/try+-process-cli!
     (fn []
       (-> args
           (kitchensink/cli! specs required)
           first
           validate-file-exists!
           construct-base-url
           utils/validate-cli-base-url!)))))

(defn -main
  [& args]
  (let [{:keys [infile base-url]} (validate-cli! args)
        command-versions (:command_versions (parse-metadata infile))]
    ;; TODO: do we need to deal with SSL or can we assume this only works over a plaintext port?
    (with-open [tar-reader (archive/tarball-reader infile)]
      (doseq [tar-entry (archive/all-entries tar-reader)]
        (process-tar-entry tar-reader tar-entry base-url command-versions)))))
